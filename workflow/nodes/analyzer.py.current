"""
쿼리 분석 노드
- Phase 7: LLM 기반 의미 분류 (키워드 규칙 제거)
- LLM 기반 쿼리 유형 분류 (sql/rag/hybrid/simple)
- 의도 추출 및 엔티티 타입 식별
- 관련 테이블 추론

NOTE: Phase 7에서 규칙 기반 분류 제거됨
- is_complex_query(): DEPRECATED (사용하지 않음)
- _check_rule_based_query(): DEPRECATED (사용하지 않음)
"""

import sys
import os
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

import json
import logging
import re
from typing import Dict, List, Any, Optional, Tuple

from workflow.state import AgentState
from llm.llm_client import get_llm_client

logger = logging.getLogger(__name__)

# Reasoning Mode 사용 여부 설정
# Phase 52 테스트 결과: 기본 모드(false)가 복합 의도 분해에서 더 정확함
# - 기본 모드 subtype 정확도: 87.5%
# - 추론 모드 subtype 정확도: 75.0%
USE_REASONING_MODE = os.getenv("USE_REASONING_MODE", "false").lower() == "true"

# Phase 64: 국가 키워드 매핑 상수
# 국가 키워드 → 국가 코드 변환 (keywords에서 제거 및 structured_keywords['country']로 이동)
COUNTRY_KEYWORDS = {
    "KR": ["한국", "국내", "대한민국", "자국", "kr", "KR"],
    "US": ["미국", "USA", "us", "US"],
    "JP": ["일본", "jp", "JP"],
    "CN": ["중국", "cn", "CN"],
    "EU": ["유럽", "eu", "EU"],
    "NOT_KR": ["해외", "타국", "외국"]
}

# 복합 질의 감지 패턴 (Phase 20)
COMPLEXITY_PATTERNS = {
    # 접속사 패턴 (공백 포함하여 정확히 매칭)
    "conjunctions": ["와 ", "과 ", "및 ", "그리고 ", " and "],
    # 다중 요청 동사
    "multi_request": ["알려주고", "해주고", "보여주고", "찾아주고", "추천해주고"],
    # 리스트 마커
    "list_markers": ["첫째", "둘째", "1)", "2)", "①", "②", "1.", "2."],
}

# 쿼리 분류 프롬프트 (Phase 76: 의도 기반 분류로 개선)
QUERY_CLASSIFICATION_PROMPT = """질문의 **의도**를 분석하여 JSON으로 응답하세요.

## 핵심 원칙
**표현(키워드)이 아닌 목적(의도)**으로 분류하세요:
- "찾아줘", "추천해줘", "알려줘", "뭐가 있어?" → 모두 동일한 **검색 의도**일 수 있음
- 실제로 사용자가 **무엇을 원하는지** 파악하세요

```json
{{
    "query_type": "sql|rag|hybrid|simple",
    "query_subtype": "list|aggregation|ranking|concept|compound|recommendation|comparison",
    "intent": "의도 설명",
    "entity_types": ["patent","project","equip","org","evalp","ancm","proposal","tech"],
    "keywords": ["핵심_키워드"],
    "related_tables": ["테이블명"],
    "is_aggregation": true|false,
    "is_compound": true|false,
    "sub_queries": [],
    "structured_keywords": {{"tech":[],"org":[],"country":[],"region":[],"filter":[],"metric":[]}}
}}
```

## query_subtype 분류 (의도 기반)

| 유형 | 사용자가 원하는 것 | 판단 기준 |
|------|------------------|----------|
| list | 조건에 맞는 데이터 목록 | 특정 조건의 데이터를 검색하고 싶음 |
| aggregation | 통계/집계 결과 | 그룹별 수치, 추이, 분포를 알고 싶음 |
| ranking | 순위 정보 | 상위 N개, 가장 많은/적은 것을 알고 싶음 |
| recommendation | 맞춤 추천 | 사용자 상황에 최적화된 선택이 필요함 |
| comparison | 비교 분석 | 두 개 이상 대상의 차이를 알고 싶음 |
| concept | 개념 설명 | 용어나 개념의 의미를 알고 싶음 |
| compound | 복합 요청 | 서로 다른 유형의 요청이 2개 이상 |

## 중요: list vs recommendation 구분

### list (검색/조회) - 대부분의 질문이 여기에 해당
- 조건에 맞는 데이터를 찾는 것이 목적
- "마찰견뢰도 장비 추천해줘" → **list** (조건 검색, "추천"은 표현일 뿐)
- "반도체 특허 찾아줘" → **list**
- "AI 관련 장비 뭐가 있어?" → **list**

### recommendation (맞춤 추천) - 사용자 상황이 명시된 경우만
- 사용자의 **구체적 상황/제약조건**이 있고, 그에 **최적화**된 선택 필요
- "우리 회사(직원 50명)에 맞는 협력기관 추천" → **recommendation**
- "이 기술로 협업할 기관 추천해줘" → **recommendation** (협업 매칭)

### 판단 질문
"사용자가 단순히 조건에 맞는 목록을 원하는가?" → **list**
"사용자 상황에 맞는 최적 선택을 원하는가?" → **recommendation**

## is_compound 판단 (의미 기반 - 중요!):

compound는 **처리 방식(subtype)이 다른 독립적 요청**이 있을 때만 true:
- "연도별 추이와 최근 목록" → **compound=True** (aggregation + list = 다른 SQL)
- "TOP 5와 총 건수" → **compound=True** (ranking + aggregation = 다른 처리)

compound가 **아닌** 경우 (compound=False):
- "AI 특허와 연구장비" → 1개 요청, 2개 엔티티 (같은 주제의 다중 엔티티 검색)
- "삼성과 LG 비교" → 1개 요청 (comparison subtype)
- "특허 목록과 출원인 정보" → 1개 요청 (JOIN으로 해결)

**핵심 판단 기준**: "와/과"가 있어도 **같은 subtype**이면 compound=False
- 같은 주제의 여러 엔티티 → entity_types에 추가, compound=False
- 다른 분석 유형 (aggregation+list, ranking+concept) → compound=True

## sub_queries (compound=true일 때만):
각 하위 요청은 **서로 다른 subtype**을 가져야 함:
```json
"sub_queries": [
    {{"intent": "연도별 추이", "subtype": "aggregation", "keywords": [...]}},
    {{"intent": "최근 목록", "subtype": "list", "keywords": [...]}}
]
```

## recommendation의 query_type 판단:
- **sql**: 구체적 키워드 있음 ("마찰견뢰도 장비 추천" → sql)
- **rag**: 추상적 요구 ("협력 기관 추천" → rag)

## is_aggregation:
- **true**: 통계/집계/랭킹 (연도별, TOP N)
- **false**: 개별 목록 (5개 알려줘)

## query_type 판단 (중요!):

### SQL 우선 엔티티 (무조건 sql):
- **evalp**: 평가표, 배점표, 평가기준 관련 → query_type=**sql**
  - "세부 항목", "상세", "전체 항목", "개별 항목", "항목별" 키워드 → entity_types에 **evalp_detail** 사용
  - 그 외 (목록, 요약) → entity_types에 **evalp** 사용
- **ancm**: 공고문, 모집, 사업공고 관련 → query_type=**sql**, query_subtype=**list**
- 예: "기술혁신개발사업 평가표 알려줘" → sql (list), evalp (요약)
- 예: "기술혁신개발사업 평가표 세부 항목" → sql (list), evalp_detail (개별 행)
- 예: "2024년 R&D 사업 공고 목록" → sql (list), ancm

### 일반 규칙:
- **sql**: 목록/수량/통계 조회 (구체적 키워드로 DB 검색 가능)
- **rag**: 개념 설명/유사 검색/맥락 분석 (텍스트 의미 기반)
  - 단, "~란?", "~란 무엇인가" 형태의 **개념 질문**만 rag (concept)
  - 예: "평가표란 무엇인가?" → rag (concept)
- **hybrid**: SQL 데이터 + RAG 분석이 **모두** 필요한 경우:
  - "협업/협력 기관 추천" → 제안서 기반 참여기관 검색 + 기술 매칭 분석
  - "시장 동향 분석" → 통계 데이터 + 트렌드 해석 필요
  - **협업 기관 추천 키워드** (중요!): "협업", "협력", "기관 추천", "파트너", "공동연구", "협력기관", "협업기관"
    - 예: "인공지능 관련 협업 기관 추천" → query_type=**hybrid**, entity_types=["proposal"], subtype=recommendation
    - 예: "반도체 협력 기업 추천" → query_type=**hybrid**, entity_types=["proposal"]
    - **주의**: "기술분류 추천"과 구분! "분류"/"분류코드" 키워드 없으면 협업 기관 추천임
- **simple**: 인사/도움말

## 엔티티 → 테이블 (키워드 예시):
- patent: f_patents, f_patent_applicants (특허, 출원, 등록, 발명)
- project: f_projects (과제, 연구과제, 프로젝트, R&D)
- equip: f_equipments (장비, 기기, 측정, 분석장비, **기관 보유 장비**)
  - **중요**: "A기관 보유 장비", "A기관 장비리스트" → equip (기관이 아님!)
  - 기관명이 포함되어도 최종 조회 대상이 장비면 equip 사용
- proposal: f_proposal_profile (기업 프로필, 기업 역량)
- evalp: f_ancm_evalp (배점표, 평가표, 가점, 평가기준 **목록**) → **SQL 우선**
- evalp_detail: f_ancm_evalp (배점표 **세부 항목**, 전체 항목, 개별 항목) → **SQL 우선**
- ancm: f_ancm_prcnd (공고문, 모집, 지원사업, 공모) → **SQL 우선**

## 키워드 추출:
- 기술 용어는 분리 금지: "수소연료전지"✅ "수소","연료전지"✗
- **기관/기업명도 핵심 키워드로 추출** (중요!)
  - "서울테크노파크 보유 장비" → keywords: ["서울테크노파크"] (장비 제외!)
  - "삼성전자 특허" → keywords: ["삼성전자"]
- **일반 단어 제외** (중요!): 장비, 리스트, 목록, 보유, 추천, 시험, 측정 → 키워드에서 제외
  - "장비리스트", "특허목록", "과제리스트" 등은 키워드가 아님
- structured_keywords 분류:
  - tech: 기술/주제 ("반도체")
  - org: 기관/기업명 ("서울테크노파크", "삼성전자") ← Phase 59 추가
  - country: 국가 코드 (**중요! 반드시 코드로 변환, keywords에서 제외**)
    - "한국", "국내", "KR", "대한민국" → ["KR"]
    - "미국", "US", "USA" → ["US"]
    - "일본", "JP" → ["JP"]
    - "중국", "CN" → ["CN"]
    - "유럽", "EU" → ["EU"]
    - "자국" → ["KR"], "해외"/"타국" → ["NOT_KR"]
    - 예: "한국 특허" → country: ["KR"], keywords: ["특허"] (한국은 keywords에서 제외!)
  - region: 지역 ("강원", "서울", "부산", "경기")
  - filter: 조건 ("TOP 10", "최근 2년")
  - metric: 분석 ("추이", "급증")

질문: {query}
"""


def is_complex_query(query: str) -> Tuple[bool, str]:
    """[DEPRECATED - Phase 7] 복합 질의 여부 판단

    NOTE: 이 함수는 더 이상 사용되지 않습니다.
    키워드 기반 패턴 매칭 대신 LLM 기반 분류를 사용합니다.

    Args:
        query: 사용자 질문

    Returns:
        (is_complex, reason): 복합 여부와 판단 이유
    """
    query_lower = query.lower()

    # 패턴 1: 접속사 감지 (서로 다른 요청을 연결)
    for conj in COMPLEXITY_PATTERNS["conjunctions"]:
        if conj in query:
            return True, f"접속사 '{conj.strip()}' 감지"

    # 패턴 2: 다중 요청 동사
    for verb in COMPLEXITY_PATTERNS["multi_request"]:
        if verb in query_lower:
            return True, f"다중 요청 동사 '{verb}' 감지"

    # 패턴 3: 리스트 마커
    for marker in COMPLEXITY_PATTERNS["list_markers"]:
        if marker in query:
            return True, f"리스트 마커 '{marker}' 감지"

    # 패턴 4: 다중 엔티티 타입 감지
    try:
        from workflow.prompts.domain_mapping import infer_entity_types
        entity_types = infer_entity_types(query)
        if len(entity_types) >= 2:
            return True, f"다중 엔티티 타입 감지: {entity_types}"
    except ImportError:
        pass

    return False, "단순 질의"


def analyze_query(state: AgentState) -> AgentState:
    """쿼리 분석 노드

    Phase 20: LLM 우선 파이프라인 재설계
    - 복합 질의: LLM 분해 → 다중 실행
    - 단순 질의: 규칙 기반 fast-path

    사용자 질문을 분석하여 쿼리 유형, 의도, 엔티티 타입, 관련 테이블을 결정.

    Args:
        state: 현재 에이전트 상태

    Returns:
        업데이트된 상태 (query_type, query_intent, entity_types, related_tables, keywords)
    """
    query = state.get("query", "")

    if not query.strip():
        return {
            **state,
            "query_type": "simple",
            "query_intent": "빈 질문",
            "error": "질문이 비어있습니다."
        }

    # 1. 간단한 규칙 기반 사전 분류 (인사/도움말) - 항상 먼저 체크
    simple_check = _check_simple_query(query)
    if simple_check:
        return {**state, **simple_check}

    # 2. LLM 기반 분류 (유일한 분류 방법) - Phase 7: 의미 기반 분류
    # 키워드 패턴이 아닌 LLM의 의미 이해를 통해 분류
    # 규칙 기반은 사용하지 않음 (오류로 처리)
    logger.info("LLM 기반 의미 분류 시작")
    try:
        return _analyze_with_basic_llm(state, query)
    except Exception as e:
        # LLM 분류 실패 시 오류 반환 (규칙 기반 폴백 제거)
        logger.error(f"LLM 분류 실패: {e}")
        return {
            **state,
            "query_type": "simple",
            "query_intent": "분류 실패",
            "entity_types": [],
            "related_tables": [],
            "keywords": [],
            "error": f"쿼리 분류 실패: LLM 호출 오류 - {str(e)}"
        }


def _check_simple_query(query: str) -> Dict[str, Any] | None:
    """간단한 규칙 기반 사전 분류"""
    query_lower = query.lower().strip()

    # 인사말
    greetings = ["안녕", "hello", "hi", "반갑", "안녕하세요"]
    if any(g in query_lower for g in greetings):
        return {
            "query_type": "simple",
            "query_intent": "인사",
            "entity_types": [],
            "related_tables": [],
            "keywords": []
        }

    # 도움말
    help_words = ["도움", "help", "사용법", "가이드"]
    if any(h in query_lower for h in help_words):
        return {
            "query_type": "simple",
            "query_intent": "도움말 요청",
            "entity_types": [],
            "related_tables": [],
            "keywords": []
        }

    return None


def _check_rule_based_query(query: str) -> Dict[str, Any] | None:
    """[DEPRECATED - Phase 7] 규칙 기반 사전 분류

    NOTE: 이 함수는 더 이상 사용되지 않습니다.
    키워드 기반 패턴 매칭 대신 LLM 기반 분류를 사용합니다.
    """
    query_lower = query.lower().strip()

    # 1. 배점표/평가표 관련 → sql + evalp
    # Phase 77.2: "가점", "우대조건" 제거 - 우대감점정보와 충돌 방지
    evalp_keywords = ["배점표", "배점", "평가표"]
    if any(kw in query_lower for kw in evalp_keywords):
        return {
            "query_type": "sql",
            "query_intent": "배점표/평가조건 조회",
            "entity_types": ["evalp"],
            "related_tables": ["f_ancm_evalp"],
            "keywords": [kw for kw in evalp_keywords if kw in query_lower]
        }

    # 2. 특허 + TOP N/숫자/검색 → sql + patent
    if "특허" in query_lower:
        if any(kw in query_lower for kw in ["top", "상위", "개", "목록", "검색", "찾아", "알려"]):
            return {
                "query_type": "sql",
                "query_intent": "특허 목록 조회",
                "entity_types": ["patent"],
                "related_tables": ["f_patents", "f_patent_applicants"],
                "keywords": ["특허"]
            }

    # 3. 연구 사례/동향 → rag + project
    if any(kw in query_lower for kw in ["사례", "연구사례", "연구 사례"]):
        return {
            "query_type": "rag",
            "query_intent": "연구 사례 검색",
            "entity_types": ["project"],
            "related_tables": [],
            "keywords": ["연구", "사례"]
        }

    if any(kw in query_lower for kw in ["동향", "연구동향", "연구 동향", "기술동향"]):
        return {
            "query_type": "rag",
            "query_intent": "연구/기술 동향 검색",
            "entity_types": ["project"],
            "related_tables": [],
            "keywords": ["동향"]
        }

    # 4. 신청조건/자격조건 → sql + evalp
    if any(kw in query_lower for kw in ["신청조건", "자격조건", "지원조건"]):
        return {
            "query_type": "sql",
            "query_intent": "신청조건 조회",
            "entity_types": ["evalp"],
            "related_tables": ["f_ancm_prcnd"],
            "keywords": ["신청조건"]
        }

    return None


def _analyze_with_basic_llm(state: AgentState, query: str) -> AgentState:
    """LLM 기반 분류 (Phase 52: USE_REASONING_MODE 분기 추가)"""
    try:
        llm = get_llm_client()
        prompt = QUERY_CLASSIFICATION_PROMPT.format(query=query)

        # Phase 52: 추론 모드 분기
        if USE_REASONING_MODE:
            # 기존 프롬프트에 <think> 래퍼 추가 (프롬프트 구조는 유지)
            enhanced_prompt = f"""<think>
다음 질문을 단계별로 분석하세요:
1. 핵심 의도 파악: 사용자가 원하는 것이 무엇인가?
2. 쿼리 유형 결정: sql(데이터 조회), rag(개념 설명), hybrid(둘 다), simple(인사)
3. subtype 결정: list, aggregation, ranking, recommendation, comparison, concept, compound
4. 엔티티 및 키워드 추출: 검색 대상과 핵심 키워드
5. 복합 의도 여부: 독립적인 요청이 2개 이상인가?
</think>

{prompt}"""

            logger.info("추론 모드로 쿼리 분석 시작")
            reasoning_result = llm.generate_with_reasoning(
                prompt=enhanced_prompt,
                system_prompt="JSON 형식으로 응답하세요. <think> 태그 내에서 추론 과정을 작성한 후 JSON을 출력하세요.",
                max_tokens=1500
            )
            response = reasoning_result.answer
            if reasoning_result.thinking:
                logger.debug(f"추론 과정: {reasoning_result.thinking[:200]}...")
        else:
            # 기본 모드
            response = llm.generate(
                prompt=prompt,
                system_prompt="JSON 형식으로만 응답하세요. 다른 텍스트는 포함하지 마세요.",
                max_tokens=500,
                temperature=0.3
            )

        # JSON 파싱
        result = _parse_classification_response(response)

        is_aggregation = result.get("is_aggregation", False)
        query_subtype = result.get("query_subtype", "list")

        # query_subtype 유효성 검증 (Phase 77.1: evalp_pref 추가)
        valid_subtypes = ["list", "aggregation", "ranking", "concept", "compound", "recommendation", "comparison", "impact_ranking", "citation_ranking", "nationality_ranking", "evalp_score", "evalp_pref", "pref_task_search"]
        if query_subtype not in valid_subtypes:
            query_subtype = "list"

        # Phase 72.4: TOP N 패턴이면 강제 ranking 분류
        # LLM이 ranking으로 분류하지 않아도 "TOP 10", "TOP 5" 등 패턴 감지 시 ranking으로 전환
        import re as regex_module
        top_n_pattern = regex_module.search(r'top\s*\d+', query.lower())
        if top_n_pattern and query_subtype != "ranking":
            logger.info(f"Phase 72.4: TOP N 패턴 감지 ({top_n_pattern.group()}) → query_subtype=ranking 강제 설정")
            query_subtype = "ranking"

        # Phase 76: 피인용 vs 영향력 키워드 구분
        # "피인용" → citation_ranking (평균 피인용수 기준)
        # "영향력" → impact_ranking (인용특허비율 기준)
        query_lower = query.lower()
        CITATION_KEYWORDS = {"피인용", "citation", "인용수", "인용 수", "피인용수"}
        IMPACT_KEYWORDS = {"영향력", "특허 영향력", "특허영향력"}

        if top_n_pattern:
            # 피인용 키워드 우선 체크 (더 구체적)
            if any(kw in query_lower for kw in CITATION_KEYWORDS):
                logger.info(f"Phase 76: 피인용 키워드 감지 → query_subtype=citation_ranking 설정")
                query_subtype = "citation_ranking"
            # 영향력 키워드 체크
            elif any(kw in query_lower for kw in IMPACT_KEYWORDS):
                logger.info(f"Phase 76: 영향력 키워드 감지 → query_subtype=impact_ranking 설정")
                query_subtype = "impact_ranking"

        # Phase 73.1: 국적별 분리 순위 패턴 감지
        # "국적별", "자국", "타국", "국내외", "구분" 등 키워드 감지 시 nationality_ranking 강제 설정
        NATIONALITY_KEYWORDS = {"국적별", "자국", "타국", "국내외", "구분해서", "국적으로"}
        if any(kw in query_lower for kw in NATIONALITY_KEYWORDS):
            logger.info(f"Phase 73.1: 국적 분리 키워드 감지 → query_subtype=nationality_ranking 강제 설정")
            query_subtype = "nationality_ranking"

        # Phase 77: 배점표 키워드 감지 → evalp_score subtype
        # "배점표" 키워드가 있으면 특화된 쿼리 로직 사용
        EVALP_SCORE_KEYWORDS = {"배점표"}
        if any(kw in query_lower for kw in EVALP_SCORE_KEYWORDS):
            logger.info(f"Phase 77: 배점표 키워드 감지 → query_subtype=evalp_score 설정")
            query_subtype = "evalp_score"

        # Phase 77.1: 우대감점정보 키워드 감지 → evalp_pref subtype
        # "우대감점", "가점정보", "감점정보" 등 키워드가 있으면 특화된 쿼리 로직 사용
        EVALP_PREF_KEYWORDS = {"우대감점", "우대감점정보", "가점정보", "감점정보", "우대조건"}
        if any(kw in query_lower for kw in EVALP_PREF_KEYWORDS):
            logger.info(f"Phase 77.1: 우대감점 키워드 감지 → query_subtype=evalp_pref 설정")
            query_subtype = "evalp_pref"

        # Phase 79: 우대조건 기반 유리한 과제 검색 → pref_task_search subtype
        # "유리한 과제", "우대 과제" 등 키워드와 기업 조건 키워드가 함께 있으면 특화된 쿼리 사용
        # Phase 79.2: 키워드 매칭 개선 - 단어 단위가 아닌 문자열 포함으로 검색
        PREF_TASK_PATTERNS = ["유리한 과제", "우대 과제", "유리한 사업", "우대 사업", "유리한과제", "우대과제", "유리한"]
        PREF_CONDITION_KEYWORDS = {"여성기업", "장애인기업", "벤처기업", "이노비즈", "메인비즈", "소재부품장비", "소재부품", "유니콘", "여성", "장애인"}

        # 띄어쓰기 제거 버전으로도 확인
        query_no_space = query_lower.replace(" ", "")
        is_pref_task_query = any(kw.replace(" ", "") in query_no_space for kw in PREF_TASK_PATTERNS)

        if is_pref_task_query:
            for cond in PREF_CONDITION_KEYWORDS:
                if cond in query_lower or cond in query_no_space:
                    logger.info(f"Phase 79: 우대조건 기반 과제 검색 감지 → query_subtype=pref_task_search 설정 (조건: {cond})")
                    query_subtype = "pref_task_search"
                    break

        # is_aggregation과 query_subtype 동기화 (Phase 76: citation_ranking 추가)
        if query_subtype in ["aggregation", "ranking", "impact_ranking", "citation_ranking", "nationality_ranking"]:
            is_aggregation = True

        # Phase 34.5: 구조화된 키워드 처리
        structured_keywords = result.get("structured_keywords")
        if structured_keywords:
            # 유효성 검증
            if not isinstance(structured_keywords, dict):
                structured_keywords = None
            else:
                # 필수 키 확인 (Phase 59: org 추가)
                for key in ["tech", "org", "country", "region", "filter", "metric"]:
                    if key not in structured_keywords:
                        structured_keywords[key] = []
        else:
            # structured_keywords가 없으면 초기화
            structured_keywords = {"tech": [], "org": [], "country": [], "region": [], "filter": [], "metric": []}

        # Phase 64: 국가 키워드 후처리 - 폴백 + keywords에서 제거
        keywords = result.get("keywords", [])

        # 1. structured_keywords['country']가 비어있으면 원본 쿼리에서 국가 코드 추출
        if not structured_keywords.get("country"):
            for code, country_words in COUNTRY_KEYWORDS.items():
                if any(kw in query for kw in country_words):
                    structured_keywords["country"] = [code]
                    logger.info(f"Phase 64: 국가 키워드 폴백 - {code}")
                    break

        # 2. (핵심!) keywords에서 국가 키워드 제거 - SQL이 '%한국%' 조건 생성 방지
        all_country_words = set()
        for words in COUNTRY_KEYWORDS.values():
            all_country_words.update(words)

        original_keywords = keywords.copy()
        keywords = [kw for kw in keywords if kw not in all_country_words]

        if len(keywords) < len(original_keywords):
            removed = set(original_keywords) - set(keywords)
            logger.info(f"Phase 64: 국가 키워드 제거됨 - {removed}, 남은 keywords: {keywords}")

        # Phase 36.1: 복합 의도 분해 처리
        is_compound = result.get("is_compound", False)
        sub_queries = result.get("sub_queries", [])

        # is_compound와 query_subtype 동기화
        if is_compound and sub_queries:
            query_subtype = "compound"

        logger.info(f"쿼리 분석 결과: type={result.get('query_type')}, subtype={query_subtype}, is_aggregation={is_aggregation}, is_compound={is_compound}, intent={result.get('intent', '')[:50]}")
        if structured_keywords:
            logger.info(f"구조화된 키워드: tech={structured_keywords.get('tech', [])}, country={structured_keywords.get('country', [])}, region={structured_keywords.get('region', [])}")
        if is_compound and sub_queries:
            logger.info(f"복합 질의 분해: {len(sub_queries)}개 하위 질의")

        # Phase 74: 협업 추천 쿼리 entity_types/related_tables 확장
        COLLABORATION_KEYWORDS = {"협업", "협력", "파트너", "공동연구", "기관추천", "기업추천"}
        is_collaboration_query = any(kw in query for kw in COLLABORATION_KEYWORDS)

        entity_types = result.get("entity_types", [])
        related_tables = result.get("related_tables", [])

        # Phase 77.5: 우대감점정보 쿼리 - entity_types/related_tables 강제 설정
        # 프론트엔드에서 analysis_complete 이벤트로 전송되므로 analyzer에서 설정해야 함
        if query_subtype == "evalp_pref":
            entity_types = ["evalp"]  # 평가 관련
            related_tables = ["f_ancm_prcnd"]  # 우대조건 테이블
            logger.info(f"Phase 77.5: 우대감점 쿼리 - entity_types={entity_types}, related_tables={related_tables}")

        # Phase 79: 우대조건 기반 유리한 과제 검색 - entity_types/related_tables 강제 설정
        if query_subtype == "pref_task_search":
            entity_types = ["evalp"]  # 평가/공고 관련
            related_tables = ["f_ancm_prcnd"]  # 우대조건 테이블
            logger.info(f"Phase 79: 우대조건 기반 과제 검색 - entity_types={entity_types}, related_tables={related_tables}")

        if is_collaboration_query:
            # proposal이 있으면 patent도 추가
            if "proposal" in entity_types and "patent" not in entity_types:
                entity_types.append("patent")
            elif not entity_types:
                entity_types = ["proposal", "patent"]

            # related_tables 확장
            related_tables = [
                "f_proposal_profile", "f_proposal_orgn",
                "f_patents", "f_patent_applicants"
            ]
            logger.info(f"Phase 74: 협업 추천 쿼리 - entity_types={entity_types}, related_tables={related_tables}")

        return {
            **state,
            "query_type": result.get("query_type", "rag"),
            "query_subtype": query_subtype,
            "query_intent": result.get("intent", ""),
            "entity_types": entity_types,  # Phase 74: 협업 추천 시 확장
            "related_tables": related_tables,  # Phase 74: 협업 추천 시 확장
            "keywords": keywords,  # Phase 64: 국가 키워드 제거된 버전 사용
            "structured_keywords": structured_keywords,  # Phase 34.5
            "is_aggregation": is_aggregation,
            "is_compound": is_compound,  # Phase 36.1
            "sub_queries": sub_queries   # Phase 36.1
        }

    except Exception as e:
        logger.error(f"쿼리 분석 실패: {e}")
        # 폴백: RAG로 처리
        return {
            **state,
            "query_type": "rag",
            "query_intent": query,
            "error": f"쿼리 분석 실패: {str(e)}"
        }


def _parse_classification_response(response: str) -> Dict[str, Any]:
    """LLM 응답에서 JSON 파싱"""
    # 코드 블록 제거
    response = re.sub(r'```json\s*', '', response)
    response = re.sub(r'```\s*', '', response)
    response = response.strip()

    try:
        result = json.loads(response)
    except json.JSONDecodeError:
        # JSON 추출 시도
        json_match = re.search(r'\{[^{}]*\}', response, re.DOTALL)
        if json_match:
            try:
                result = json.loads(json_match.group())
            except json.JSONDecodeError:
                result = {}
        else:
            result = {}

    # 유효성 검증
    valid_types = ["sql", "rag", "hybrid", "simple"]
    if result.get("query_type") not in valid_types:
        result["query_type"] = "rag"

    return result
